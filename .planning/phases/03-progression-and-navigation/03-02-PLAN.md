---
phase: 03-progression-and-navigation
plan: "02"
type: execute
wave: 2
depends_on:
  - "03-01"
files_modified:
  - src/App.tsx
  - src/components/GameScreen.tsx
autonomous: true
requirements:
  - PROG-01
  - PROG-02

must_haves:
  truths:
    - "App opens at level select on every load — never jumps directly into a level"
    - "The first incomplete level (< 3 stars) is highlighted and scrolled into view"
    - "Tapping a level cell in LevelSelect starts that level in GameScreen"
    - "Unlock state is derived from loadAllProgress() bestStars >= 2 — no separate unlock field written"
    - "GameScreen initializes at the correct level passed from App.tsx (not always LEVELS[0])"
  artifacts:
    - path: "src/App.tsx"
      provides: "Screen router ('levelSelect' | 'playing'), findFirstIncompleteLevel(), handleSelectLevel, handleReturnToSelect"
      contains: "useState<Screen>"
    - path: "src/components/GameScreen.tsx"
      provides: "Accepts initialLevelIndex and onReturnToSelect props"
      contains: "initialLevelIndex"
  key_links:
    - from: "src/App.tsx"
      to: "src/components/LevelSelect/LevelSelect.tsx"
      via: "Renders <LevelSelect> when screen === 'levelSelect'"
      pattern: "screen.*levelSelect"
    - from: "src/App.tsx"
      to: "src/components/GameScreen.tsx"
      via: "Renders <GameScreen initialLevelIndex={currentLevelIndex} onReturnToSelect={handleReturnToSelect}> when screen === 'playing'"
      pattern: "initialLevelIndex"
    - from: "src/components/GameScreen.tsx"
      to: "src/game/storage.ts"
      via: "saveProgress called after level complete (already present); no change needed"
      pattern: "saveProgress"
---

<objective>
Wire App.tsx as a lightweight screen router and update GameScreen to accept a starting level index.

Purpose: App.tsx currently renders GameScreen unconditionally at LEVELS[0]. This plan adds a 'levelSelect' | 'playing' screen state so LevelSelect becomes the entry point, and adds initialLevelIndex + onReturnToSelect props to GameScreen so the selected level actually loads.
Output: Modified App.tsx with screen router; modified GameScreen.tsx with initialLevelIndex prop.
</objective>

<execution_context>
@/Users/martha2022/.claude/get-shit-done/workflows/execute-plan.md
@/Users/martha2022/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-progression-and-navigation/03-CONTEXT.md
@.planning/phases/03-progression-and-navigation/03-RESEARCH.md

@src/App.tsx
@src/components/GameScreen.tsx
@src/game/storage.ts
@src/game/levels.ts
@.planning/phases/03-progression-and-navigation/03-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: App.tsx screen router with findFirstIncompleteLevel</name>
  <files>src/App.tsx</files>
  <action>
Rewrite src/App.tsx to add screen state routing.

New App.tsx structure:
```typescript
import { useState } from 'react';
import { ThemeProvider } from './ui/ThemeProvider';
import { GameScreen } from './components/GameScreen';
import { LevelSelect } from './components/LevelSelect/LevelSelect';
import { LEVELS } from './game/levels';
import { loadAllProgress } from './game/storage';

type Screen = 'levelSelect' | 'playing';

function findFirstIncompleteLevel(): number {
  // "incomplete" = never earned 3★ — encourages replaying for perfection
  const progress = loadAllProgress();
  for (let i = 0; i < LEVELS.length; i++) {
    const p = progress[LEVELS[i].id];
    if (!p || p.stars < 3) return i;
  }
  // All levels are 3★ — focus last level
  return LEVELS.length - 1;
}

export default function App() {
  const [screen, setScreen] = useState<Screen>('levelSelect');
  const [currentLevelIndex, setCurrentLevelIndex] = useState<number>(
    () => findFirstIncompleteLevel()
  );

  const handleSelectLevel = (index: number) => {
    setCurrentLevelIndex(index);
    setScreen('playing');
  };

  const handleReturnToSelect = () => {
    setScreen('levelSelect');
    // Re-compute focus after returning — player may have just earned stars
    setCurrentLevelIndex(findFirstIncompleteLevel());
  };

  return (
    <ThemeProvider>
      {screen === 'levelSelect' ? (
        <LevelSelect
          onSelectLevel={handleSelectLevel}
          currentFocusIndex={currentLevelIndex}
        />
      ) : (
        <GameScreen
          initialLevelIndex={currentLevelIndex}
          onReturnToSelect={handleReturnToSelect}
        />
      )}
    </ThemeProvider>
  );
}
```

Key points:
- `findFirstIncompleteLevel` is a module-level function (not inside component) to keep lazy initializer clean
- `loadAllProgress()` is called synchronously — no async/await, no useEffect
- The screen swap (levelSelect ↔ playing) naturally unmounts/remounts each component — no key prop needed
- Do NOT use React Router or any router library
- Do NOT store unlock state separately — it is always derived from progress stars
  </action>
  <verify>
    <automated>cd /Users/martha2022/Documents/Sleevo && npx tsc --noEmit 2>&1 | head -30</automated>
    <manual>App.tsx contains useState&lt;Screen&gt;, renders LevelSelect when screen==='levelSelect' and GameScreen when screen==='playing'</manual>
  </verify>
  <done>App.tsx compiles without TypeScript errors; contains screen state router; initializes at 'levelSelect'; passes initialLevelIndex and onReturnToSelect to GameScreen</done>
</task>

<task type="auto">
  <name>Task 2: GameScreen initialLevelIndex and onReturnToSelect props</name>
  <files>src/components/GameScreen.tsx</files>
  <action>
Modify src/components/GameScreen.tsx to accept `initialLevelIndex: number` and `onReturnToSelect: () => void` props.

Changes required:

1. Add Props interface near the top of the file:
```typescript
interface Props {
  initialLevelIndex: number;
  onReturnToSelect: () => void;
}
```

2. Update the function signature from:
```typescript
export function GameScreen() {
```
to:
```typescript
export function GameScreen({ initialLevelIndex, onReturnToSelect }: Props) {
```

3. Update the useReducer lazy initializer from:
```typescript
const [state, dispatch] = useReducer(gameReducer, null, () =>
  createGameState(LEVELS[0], 0)
);
```
to:
```typescript
const [state, dispatch] = useReducer(gameReducer, null, () =>
  createGameState(LEVELS[initialLevelIndex], initialLevelIndex)
);
```

4. Find the existing `handleNext` function (which calls `dispatch({ type: 'NEXT_LEVEL', ... })`) and the place where LevelComplete is rendered. Per the research recommendation, `handleNext` / `NEXT_LEVEL` dispatch path is used by the "Livello successivo →" button in LevelComplete. After Phase 3, LevelComplete's "Continue" will be wired in Plan 03 to return to level select instead. For this plan: keep `handleNext` in place BUT add `onReturnToSelect` to the LevelComplete props so Plan 03 can wire it. The prop will be plumbed but not yet used by LevelComplete itself (Plan 03 handles that).

Specifically: find the `<LevelComplete ... onNextLevel={handleNext}` render in GameScreen.tsx and add `onReturnToSelect={onReturnToSelect}` as a prop pass-through so Plan 03 can wire it without touching GameScreen again. If LevelComplete's Props interface doesn't yet accept `onReturnToSelect`, skip this prop addition — Plan 03 will add it to the interface and wire it end-to-end.

Actually: do NOT add `onReturnToSelect` to LevelComplete's call site yet — Plan 03 owns LevelComplete.tsx. Just ensure GameScreen itself compiles with its new Props. The `onReturnToSelect` callback sits in App.tsx and will be threaded through GameScreen → LevelComplete in Plan 03.

Wait — to avoid Plan 03 having to re-touch GameScreen.tsx, pass `onReturnToSelect` to LevelComplete now IF LevelComplete already accepts it. If LevelComplete does not yet have `onReturnToSelect` in its Props interface (which it won't until Plan 03), then simply store it on the GameScreen instance and leave a comment:
```typescript
// onReturnToSelect is passed to LevelComplete in Plan 03
```

Best approach for clean separation: GameScreen receives `onReturnToSelect` as a prop and passes it down to LevelComplete as `onNextLevel={onReturnToSelect}` (replacing the existing `onNextLevel={handleNext}`). This way LevelComplete.tsx doesn't need a new prop — it already has `onNextLevel`. Plan 03 then only needs to update the LevelComplete button label.

So: in GameScreen.tsx, replace `onNextLevel={handleNext}` with `onNextLevel={onReturnToSelect}` in the LevelComplete render call. This wires the "Livello successivo →" button to return to level select instead of auto-advancing to the next level.

The `handleNext` function can remain in the file (unused for now) or be removed if it has no other callers. If handleNext is only used for the LevelComplete button, remove it or mark it unused — do not delete if it's also used by Controls or other elements. Check existing usage before removing.

Tutorial logic: the `shouldShowTutorial()` check uses `state.levelIndex === 0`. This remains correct — no change needed. `state.levelIndex` is set from `initialLevelIndex` via `createGameState`, so level 1 still gets the tutorial.
  </action>
  <verify>
    <automated>cd /Users/martha2022/Documents/Sleevo && npx tsc --noEmit 2>&1 | head -30</automated>
    <manual>GameScreen.tsx has Props interface with initialLevelIndex and onReturnToSelect; useReducer uses createGameState(LEVELS[initialLevelIndex], initialLevelIndex); LevelComplete onNextLevel={onReturnToSelect}</manual>
  </verify>
  <done>GameScreen.tsx compiles without TypeScript errors; accepts initialLevelIndex prop; initializes useReducer from initialLevelIndex; LevelComplete's onNextLevel now calls onReturnToSelect (returns to level select, not auto-advance)</done>
</task>

</tasks>

<verification>
Run `npx tsc --noEmit` from project root — must report 0 errors.
Run `npm run dev` (or `npx vite`) and open the app — should open at level select, not directly at gameplay.
Level 1 should be clickable (unlocked); levels 2+ should be locked (dimmed with padlock) if no progress exists in localStorage.
Clicking a level should navigate to gameplay at that level.
</verification>

<success_criteria>
- TypeScript compiles clean (0 errors)
- App opens at level select on load
- findFirstIncompleteLevel() correctly identifies index of first level with < 3 stars
- Selecting a level sets currentLevelIndex and switches to 'playing' screen
- GameScreen initializes useReducer from initialLevelIndex (not hardcoded LEVELS[0])
- Returning from a level (onReturnToSelect) takes user back to level select and recomputes focus
</success_criteria>

<output>
After completion, create `.planning/phases/03-progression-and-navigation/03-02-SUMMARY.md`
</output>
