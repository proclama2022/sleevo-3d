---
phase: 01-campaign-structure-star-system-foundation
plan: 04
type: execute
wave: 3
depends_on: ["01-01", "01-02", "01-03"]
files_modified:
  - services/gameLogic.ts
  - App.tsx
autonomous: false

must_haves:
  truths:
    - "Campaign levels 1-10 use hand-crafted configs instead of procedural generation"
    - "Star criteria modal appears before each campaign level starts"
    - "Star progress HUD visible during gameplay"
    - "Star celebration animation plays at level completion"
    - "Best star rating persists to SaveData after level completion"
    - "Player must complete level N to unlock level N+1"
  artifacts:
    - path: "services/gameLogic.ts"
      provides: "Level generation that uses campaign configs for levels 1-10"
      exports: ["generateLevel", "generateFromCampaignConfig"]
    - path: "App.tsx"
      provides: "Fully integrated star system in game flow"
      contains: "StarCriteria"
  key_links:
    - from: "services/gameLogic.ts"
      to: "constants/levelConfigs.ts"
      via: "import getCampaignLevel"
      pattern: "import.*getCampaignLevel"
    - from: "App.tsx"
      to: "components/StarCriteria.tsx"
      via: "import and render StarCriteria"
      pattern: "import.*StarCriteria"
    - from: "App.tsx"
      to: "components/StarProgress.tsx"
      via: "import and render StarProgress"
      pattern: "import.*StarProgress"
    - from: "App.tsx"
      to: "components/StarCelebration.tsx"
      via: "import and render StarCelebration"
      pattern: "import.*StarCelebration"
    - from: "App.tsx"
      to: "services/starCalculation.ts"
      via: "calculateStarsEarned on level win"
      pattern: "calculateStarsEarned"
    - from: "App.tsx"
      to: "services/storage.ts"
      via: "updateStarProgress on level win"
      pattern: "updateStarProgress"
---

<objective>
Wire all star system components into the game flow: integrate campaign level configs into level generation, add star UI to the game lifecycle (pre-level -> during play -> post-level), and persist results.

Purpose: This is the integration plan that makes the star system real. Without this, all prior plans are unused code. This plan delivers the complete user experience: see criteria, play level, track progress, celebrate stars, save results.

Output: Modified `services/gameLogic.ts` and `App.tsx` with full star system integration
</objective>

<execution_context>
@/Users/martha2022/.claude/get-shit-done/workflows/execute-plan.md
@/Users/martha2022/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-campaign-structure-star-system-foundation/01-01-SUMMARY.md
@.planning/phases/01-campaign-structure-star-system-foundation/01-02-SUMMARY.md
@.planning/phases/01-campaign-structure-star-system-foundation/01-03-SUMMARY.md

@types.ts
@services/gameLogic.ts
@services/storage.ts
@services/starCalculation.ts
@constants/levelConfigs.ts
@components/StarCriteria.tsx
@components/StarProgress.tsx
@components/StarCelebration.tsx
@App.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add campaign config support to level generation</name>
  <files>services/gameLogic.ts</files>
  <action>
Read the full `services/gameLogic.ts` file before modifying.

Add a new function `generateFromCampaignConfig` that converts a CampaignLevelConfig into the same return type as `generateLevel`:

```typescript
import { getCampaignLevel, CampaignLevelConfig } from '../constants/levelConfigs';

export const generateFromCampaignConfig = (
  config: CampaignLevelConfig
): { crates: Crate[], vinyls: Vinyl[], moves: number, mode: LevelMode, time: number, theme: ShopTheme } => {
  // Build crates from config.genres and config.crateCapacities
  const crates: Crate[] = config.genres.map((genre, idx) => ({
    id: `crate-${config.levelNumber}-${idx}`,
    genre,
    capacity: config.crateCapacities[idx],
    filled: 0,
    label: randomPick(GENRE_LABELS[genre]),
  }));

  const vinyls: Vinyl[] = [];

  // 1. Generate matching vinyls for each crate
  crates.forEach(crate => {
    for (let i = 0; i < crate.capacity; i++) {
      vinyls.push({
        id: `vinyl-${crate.id}-${i}`,
        type: 'vinyl',
        genre: crate.genre,
        title: randomPick(ALBUM_TITLES),
        artist: randomPick(ARTIST_NAMES),
        coverColor: GENRE_COLORS[crate.genre],
        isGold: false,
        isMystery: false,
        isRevealed: false,
        dustLevel: 0,
        isTrash: false,
      });
    }
  });

  // 2. Apply mystery flag to first N vinyls (shuffled later)
  let mysteryApplied = 0;
  for (const v of vinyls) {
    if (mysteryApplied >= config.mysteryCount) break;
    if (!v.isGold) { v.isMystery = true; mysteryApplied++; }
  }

  // 3. Apply dusty flag
  let dustyApplied = 0;
  for (const v of vinyls) {
    if (dustyApplied >= config.dustyCount) break;
    if (!v.isMystery && !v.isGold) { v.dustLevel = 3; dustyApplied++; }
  }

  // 4. Apply special discs
  let specialIdx = 0;
  for (const v of vinyls) {
    if (specialIdx >= config.specialDiscs.length) break;
    if (!v.isMystery && !v.isGold && v.dustLevel === 0) {
      v.specialType = config.specialDiscs[specialIdx];
      specialIdx++;
    }
  }

  // 5. Add trash items
  for (let i = 0; i < config.trashCount; i++) {
    vinyls.push({
      id: `trash-${config.levelNumber}-${i}`,
      type: 'trash',
      genre: Genre.Rock,
      title: randomPick(TRASH_NAMES),
      artist: "Unknown",
      coverColor: "bg-gray-500",
      isTrash: true,
      dustLevel: 0,
      isGold: false,
      isMystery: false,
    });
  }

  // 6. Shuffle vinyls
  for (let i = vinyls.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [vinyls[i], vinyls[j]] = [vinyls[j], vinyls[i]];
  }

  return {
    crates,
    vinyls,
    moves: config.moves,
    mode: config.mode,
    time: config.time,
    theme: config.theme,
  };
};
```

Modify the existing `generateLevel` function to check for campaign config first:
- At the top of generateLevel, add: `const campaignConfig = getCampaignLevel(levelIndex + 1);`
- If campaignConfig exists AND isEndlessMode is false, return `generateFromCampaignConfig(campaignConfig);`
- Otherwise, fall through to existing procedural generation (unchanged)

This ensures campaign levels use hand-crafted configs while endless mode and levels beyond 10 continue using procedural generation.

Important: Keep existing ARTIST_NAMES, ALBUM_TITLES, TRASH_NAMES arrays accessible to the new function (they're module-level already). Export ARTIST_NAMES and ALBUM_TITLES if not already exported (the new function needs them).
  </action>
  <verify>
`npx tsc --noEmit` passes. `generateLevel(0, 'Normal')` returns level 1 config from campaign (2 crates, Rock+Jazz). `generateLevel(10, 'Normal')` falls through to procedural. `generateLevel(0, 'Normal', true)` uses procedural (endless mode bypass).
  </verify>
  <done>Level generation uses hand-crafted campaign configs for levels 1-10 in non-endless mode, falls through to procedural generation for levels 11+ and endless mode.</done>
</task>

<task type="auto">
  <name>Task 2: Integrate star system into App.tsx game flow</name>
  <files>App.tsx</files>
  <action>
Read the FULL App.tsx file before making any modifications (it's ~2225 lines). This is a large file -- make surgical, targeted changes.

**Changes to make:**

1. **Add imports** (at top of file, with other imports):
   ```typescript
   import { StarCriteria } from './components/StarCriteria';
   import { StarProgress } from './components/StarProgress';
   import { StarCelebration } from './components/StarCelebration';
   import { getStarCriteria, calculateStarsEarned, calculateCurrentStars, StarCriteria as StarCriteriaType } from './services/starCalculation';
   import { updateStarProgress } from './services/storage';
   import { getCampaignLevel } from './constants/levelConfigs';
   ```

2. **Add state variables** (near other useState declarations):
   ```typescript
   const [showStarCriteria, setShowStarCriteria] = useState(false);
   const [currentStarCriteria, setCurrentStarCriteria] = useState<StarCriteriaType | null>(null);
   const [showStarCelebration, setShowStarCelebration] = useState(false);
   const [levelStarsResult, setLevelStarsResult] = useState(0);
   const [isNewBestStars, setIsNewBestStars] = useState(false);
   ```

3. **Modify level start flow** -- Find where the game transitions from menu to playing (look for where gameState.status is set to 'playing' or where generateLevel is called). BEFORE the level starts:
   - Calculate star criteria: `const criteria = getStarCriteria(gameState.currentLevel, mode);`
   - Store criteria: `setCurrentStarCriteria(criteria);`
   - Show criteria modal: `setShowStarCriteria(true);`
   - The actual level start (setting status to 'playing') should happen in the StarCriteria's onStart callback

4. **Add StarProgress to game HUD** -- Find the in-game UI section (where InGameStats, SecondaryObjectives render during 'playing' status). Add StarProgress component:
   ```tsx
   {gameState.status === 'playing' && currentStarCriteria && (
     <StarProgress
       currentStars={calculateCurrentStars(gameState, currentStarCriteria)}
       criteria={currentStarCriteria}
       accuracy={gameState.totalMoves > 0 ? (gameState.totalMoves - gameState.mistakes) / gameState.totalMoves : 1}
       showDetails={!isMobile}
     />
   )}
   ```
   Position this near the existing score/combo display area.

5. **Modify level completion flow** -- Find where gameState.status becomes 'won'. After win detection:
   - Calculate stars: `const stars = calculateStarsEarned(gameState, currentStarCriteria!);`
   - Update gameState.starsEarned: `setGameState(prev => ({ ...prev, starsEarned: stars }));`
   - Check if new best: `const prevBest = saveData.levelStars[gameState.currentLevel] || 0;`
   - Set celebration state: `setLevelStarsResult(stars); setIsNewBestStars(stars > prevBest); setShowStarCelebration(true);`
   - Persist stars: Call `updateStarProgress(saveData, gameState.currentLevel, stars)` and save via `saveSaveData`
   - Also update levelStars in saveData: `saveData.levelStars[gameState.currentLevel] = Math.max(prevBest, stars);`

6. **Render StarCriteria modal** -- Add to JSX (near other modals):
   ```tsx
   {showStarCriteria && currentStarCriteria && (
     <StarCriteria
       levelNumber={gameState.currentLevel + 1}
       levelName={getCampaignLevel(gameState.currentLevel + 1)?.name || `Level ${gameState.currentLevel + 1}`}
       mode={gameState.mode}
       criteria={currentStarCriteria}
       bestStars={saveData.levelStars[gameState.currentLevel] || 0}
       onStart={() => {
         setShowStarCriteria(false);
         // trigger actual level start (set status to 'playing')
       }}
     />
   )}
   ```

7. **Render StarCelebration** -- Add to JSX (near victory screen):
   ```tsx
   {showStarCelebration && (
     <StarCelebration
       starsEarned={levelStarsResult}
       isNewBest={isNewBestStars}
       onComplete={() => setShowStarCelebration(false)}
       onSkip={() => setShowStarCelebration(false)}
     />
   )}
   ```

**Critical: Read App.tsx carefully to find the exact insertion points.** The file is large and uses specific patterns. Match the existing code style. Do NOT restructure existing logic -- make additive changes only.

**Edge cases to handle:**
- Endless mode: Do NOT show star criteria or star celebration (stars don't apply)
- Lost level: Do NOT show star celebration (only on win)
- Level replay: Show previous best stars in criteria modal
  </action>
  <verify>
`npx tsc --noEmit` passes. Start the dev server with `npm run dev` and verify:
1. Starting a new game shows star criteria modal before level 1
2. During gameplay, star progress indicators are visible
3. Winning a level shows star celebration animation
4. Stars persist after completing a level (check localStorage or replay level to see "Your best")
  </verify>
  <done>Full star system integrated: criteria shown before level, progress tracked during play, celebration on win, stars persisted. Endless mode bypasses star system. Campaign levels 1-10 use hand-crafted configs.</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 3: Verify star system end-to-end</name>
  <files>App.tsx</files>
  <action>
Human verification checkpoint. Claude has automated all integration work in Tasks 1-2. This task verifies the complete star system works correctly from the user's perspective.

What was built:
- Complete star rating system with pre-level criteria display
- Real-time star progress HUD during gameplay
- Victory celebration animation with sequential star reveal
- Persistent star tracking across 10 hand-crafted campaign levels
- Campaign configs integrated into level generation
  </action>
  <verify>
1. Open the game at http://localhost:5173 (or whatever port Vite uses)
2. Start a new game (Level 1):
   - VERIFY: Star criteria modal appears showing "First Sort" and 3 tiers of star requirements
   - VERIFY: "Start Level" button is tappable
3. Click "Start Level" and play the level:
   - VERIFY: Star progress HUD visible (3 small stars near score area)
   - VERIFY: Stars fill/unfill in real-time as you sort vinyls correctly/incorrectly
4. Complete the level:
   - VERIFY: Star celebration animation plays with sequential star reveal
   - VERIFY: Stars pop in one at a time with animation
   - VERIFY: Can tap to skip animation
5. Return to menu and start Level 2:
   - VERIFY: Level 2 has different criteria than Level 1
   - VERIFY: Difficulty feels slightly harder (more crates or trash)
6. Go back and replay Level 1:
   - VERIFY: Criteria modal shows "Your best: X stars"
7. Check difficulty progression feels smooth across first 3-4 levels (no sudden spike)
  </verify>
  <done>User confirms star system works end-to-end: criteria visible before level, progress tracked during play, celebration on win, stars persisted, difficulty progression smooth.</done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes
- `npm run dev` starts without errors
- Full game flow: menu -> star criteria -> play -> star progress -> win -> star celebration -> persist
- Campaign levels 1-10 use hand-crafted configs
- Endless mode skips star system
- Star ratings persist across page refresh
</verification>

<success_criteria>
- STAR-01: User earns 1-3 stars based on performance (accuracy, combo, time, mode)
- STAR-02: User sees star criteria before level starts
- STAR-03: User sees real-time progress toward star goals during gameplay
- STAR-04: System tracks best star rating per level
- STAR-05: SaveData stores star progress for all levels
- STAR-06: Progression service calculates stars based on multiple criteria
- LEVEL-04: 10 hand-crafted levels playable with validated difficulty curve
</success_criteria>

<output>
After completion, create `.planning/phases/01-campaign-structure-star-system-foundation/01-04-SUMMARY.md`
</output>
