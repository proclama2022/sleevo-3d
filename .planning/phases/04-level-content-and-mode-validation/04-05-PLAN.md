---
phase: 04-level-content-and-mode-validation
plan: "05"
type: execute
wave: 3
depends_on:
  - "04-02"
  - "04-03"
  - "04-04"
files_modified:
  - src/components/GameScreen.tsx
autonomous: true
requirements:
  - LVLS-04
  - MODE-01
  - MODE-02
  - MODE-03
  - MODE-04

must_haves:
  truths:
    - "LevelHintOverlay appears every time a level starts (including RESTART of the same level)"
    - "LevelHintOverlay disappears only on explicit dismiss — click backdrop or Inizia button"
    - "The old blackout useEffect (setTimeout + BLACKOUT_TRIGGER) is removed; BLACKOUT_TICK interval drives it instead"
    - "CustomerPanel receives customerName from state.level.customerName"
    - "The game is fully interactive after overlay is dismissed — vinyls can be dragged"
  artifacts:
    - path: "src/components/GameScreen.tsx"
      provides: "LevelHintOverlay integration, BLACKOUT_TICK interval, customerName wired to CustomerPanel"
      contains: "LevelHintOverlay"
  key_links:
    - from: "src/components/GameScreen.tsx"
      to: "src/components/LevelHintOverlay.tsx"
      via: "JSX render conditioned on showHintOverlay state"
      pattern: "showHintOverlay"
    - from: "src/components/GameScreen.tsx"
      to: "src/game/engine.ts"
      via: "dispatch BLACKOUT_TICK via setInterval"
      pattern: "BLACKOUT_TICK"
    - from: "src/components/GameScreen.tsx"
      to: "src/components/CustomerPanel.tsx"
      via: "customerName prop passed from state.level.customerName"
      pattern: "customerName"
---

<objective>
Wire everything into GameScreen.tsx: mount LevelHintOverlay with correct reset logic, replace the old BLACKOUT_TRIGGER useEffect with a BLACKOUT_TICK interval-based useEffect, and pass customerName from the level definition to CustomerPanel.

Purpose: This is the integration plan that makes all the Phase 4 pieces work together. Plans 02-04 built the components/engine changes; this plan connects them in the single component that orchestrates gameplay.

Output: Updated src/components/GameScreen.tsx.
</objective>

<execution_context>
@/Users/martha2022/.claude/get-shit-done/workflows/execute-plan.md
@/Users/martha2022/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-level-content-and-mode-validation/04-CONTEXT.md
@.planning/phases/04-level-content-and-mode-validation/04-RESEARCH.md
@src/components/GameScreen.tsx
@src/components/LevelHintOverlay.tsx
@.planning/phases/04-level-content-and-mode-validation/04-02-SUMMARY.md
@.planning/phases/04-level-content-and-mode-validation/04-03-SUMMARY.md
@.planning/phases/04-level-content-and-mode-validation/04-04-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire LevelHintOverlay into GameScreen</name>
  <files>src/components/GameScreen.tsx</files>
  <action>
Read src/components/GameScreen.tsx fully before editing. Make the following changes:

**Step 1 — Import LevelHintOverlay:**
Add to the imports section at the top:
```typescript
import { LevelHintOverlay } from './LevelHintOverlay';
```

**Step 2 — Add showHintOverlay state:**
Inside the GameScreen function body, after the existing `useState` declarations, add:
```typescript
const [showHintOverlay, setShowHintOverlay] = useState(true);
```

**Step 3 — Reset overlay on level change (NEXT_LEVEL):**
Add a useEffect that resets the overlay when the level ID changes:
```typescript
useEffect(() => {
  setShowHintOverlay(true);
}, [state.level.id]);
```

**Step 4 — Reset overlay on RESTART:**
Find the `handleRestart` callback. It calls `dispatch({ type: 'RESTART' })` and likely resets `setTimeElapsed(0)`. Add `setShowHintOverlay(true);` to this callback:
```typescript
const handleRestart = useCallback(() => {
  setTimeElapsed(0);
  setShowHintOverlay(true);  // show hint on restart per CONTEXT
  dispatch({ type: 'RESTART' });
}, []);
```

**Step 5 — Render LevelHintOverlay in JSX:**
In the JSX return, find where the Shelf/gameplay area is rendered. Add the overlay AFTER the HUD but BEFORE (or wrapping) the shelf content. The overlay must cover the gameplay area but not require covering the entire screen layout. Render it conditionally:
```tsx
{showHintOverlay && state.status === 'playing' && (
  <LevelHintOverlay
    hint={state.level.hint ?? ''}
    mode={state.level.mode}
    onDismiss={() => setShowHintOverlay(false)}
  />
)}
```
Per RESEARCH.md pitfall note: overlay z-index is 200 (handled in CSS), which is above the shelf but does not compete with the drag ghost (z-index 1000) since the overlay only exists before any drag starts.
  </action>
  <verify>
    <automated>cd /Users/martha2022/Documents/Sleevo && npx tsc --noEmit 2>&1 | grep "GameScreen" | head -10</automated>
    <manual>Confirm import exists, showHintOverlay useState is declared, useEffect on state.level.id exists, handleRestart includes setShowHintOverlay(true), and JSX has LevelHintOverlay render</manual>
    <sampling_rate>run after this task before task 2</sampling_rate>
  </verify>
  <done>LevelHintOverlay is imported and rendered in GameScreen. showHintOverlay resets on level change AND on restart. TypeScript zero errors for this change.</done>
</task>

<task type="auto">
  <name>Task 2: Replace blackout useEffect and wire customerName</name>
  <files>src/components/GameScreen.tsx</files>
  <action>
Continue editing src/components/GameScreen.tsx (already read in Task 1).

**Step 1 — Replace the blackout useEffect:**
Find the existing blackout useEffect. Per RESEARCH.md it is approximately at lines 192-201 and uses `setTimeout` to dispatch `BLACKOUT_TRIGGER` after 3000ms. Remove this entire useEffect block.

Replace it with a new BLACKOUT_TICK interval-based useEffect:
```typescript
// Blackout mode: tick the countdown in the engine (engine handles label hide logic)
useEffect(() => {
  if (state.level.mode !== 'blackout' || state.blackoutSecondsLeft <= 0 || state.status !== 'playing') {
    return;
  }
  const timer = setInterval(() => dispatch({ type: 'BLACKOUT_TICK' }), 1000);
  return () => clearInterval(timer);
}, [state.level.mode, state.blackoutSecondsLeft, state.status]);
```

This is the pattern from RESEARCH.md Pattern 2: the hide decision lives in the engine reducer (pure), while the useEffect only drives the clock tick.

**Step 2 — Wire customerName to CustomerPanel:**
Find where `<CustomerPanel` is rendered in GameScreen JSX. It currently receives props like `genre`, `era`, `served`, etc. Add `customerName={state.level.customerName}` to the CustomerPanel JSX props. This passes the level's customerName (set in Plan 01) through to the panel.

**Step 3 — Verify no BLACKOUT_TRIGGER dispatch remains:**
After removing the old useEffect, search GameScreen.tsx for any remaining dispatch calls with `BLACKOUT_TRIGGER`. If any remain (e.g., in another handler), remove them. The BLACKOUT_TRIGGER action in engine.ts can remain as dead code for now — it causes no harm and its removal is not in scope.
  </action>
  <verify>
    <automated>cd /Users/martha2022/Documents/Sleevo && npx tsc --noEmit 2>&1 | head -20</automated>
    <manual>Confirm: (1) no setTimeout in the blackout section of GameScreen, (2) BLACKOUT_TICK setInterval exists, (3) CustomerPanel receives customerName prop in JSX</manual>
    <sampling_rate>run after — full compile must be clean</sampling_rate>
  </verify>
  <done>Full project TypeScript compile is zero errors. The old BLACKOUT_TRIGGER setTimeout useEffect is gone. A BLACKOUT_TICK setInterval useEffect exists with correct dependency array. CustomerPanel receives customerName={state.level.customerName}.</done>
</task>

</tasks>

<verification>
Run: `cd /Users/martha2022/Documents/Sleevo && npx tsc --noEmit`
Expected: zero errors across entire project.

Run: `grep -n "BLACKOUT_TRIGGER\|setTimeout" /Users/martha2022/Documents/Sleevo/src/components/GameScreen.tsx | head -10`
Expected: no BLACKOUT_TRIGGER with setTimeout (may still exist as a dispatch if referenced elsewhere, but the old blackout useEffect with setTimeout must be gone).

Run: `grep -n "BLACKOUT_TICK" /Users/martha2022/Documents/Sleevo/src/components/GameScreen.tsx`
Expected: at least 1 line (the dispatch inside setInterval).

Run: `grep -n "LevelHintOverlay\|showHintOverlay" /Users/martha2022/Documents/Sleevo/src/components/GameScreen.tsx`
Expected: import line + useState + useEffect + JSX render (4+ lines).

Run: `grep -n "customerName" /Users/martha2022/Documents/Sleevo/src/components/GameScreen.tsx`
Expected: the CustomerPanel JSX prop line.

Run: `cd /Users/martha2022/Documents/Sleevo && npm run build 2>&1 | tail -10`
Expected: successful build output.
</verification>

<success_criteria>
- Full project TypeScript compile: zero errors
- LevelHintOverlay is mounted in GameScreen JSX conditioned on showHintOverlay
- showHintOverlay resets on level change (useEffect) and on RESTART (handleRestart callback)
- BLACKOUT_TICK useEffect with setInterval replaces the old setTimeout blackout useEffect
- CustomerPanel receives customerName from state.level.customerName
- npm run build succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/04-level-content-and-mode-validation/04-05-SUMMARY.md`
</output>
