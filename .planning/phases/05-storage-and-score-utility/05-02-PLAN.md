---
phase: 05-storage-and-score-utility
plan: 02
type: execute
wave: 2
depends_on:
  - 05-01
files_modified:
  - src/components/GameScreen.tsx
autonomous: false
requirements:
  - PERSIST-01
  - PERSIST-02

must_haves:
  truths:
    - "Completing a level writes bestScore to localStorage"
    - "In-progress score increments during gameplay do not trigger saveProgress"
    - "Replaying a level and scoring lower leaves the stored bestScore unchanged"
  artifacts:
    - path: "src/components/GameScreen.tsx"
      provides: "Passes state.score to saveProgress on level completion"
      contains: "saveProgress(state.level.id, state.stars, timeElapsed, state.score)"
  key_links:
    - from: "src/components/GameScreen.tsx completion useEffect"
      to: "src/game/storage.ts saveProgress"
      via: "fourth argument state.score"
      pattern: "saveProgress\\(.*state\\.score"
---

<objective>
Wire the extended `saveProgress` signature in GameScreen so that score is persisted on level completion.

Purpose: Phase 01 extended the storage layer but nothing calls it with a score yet. This plan closes the loop — the save effect must pass `state.score` as the fourth argument so best scores are actually written to localStorage.
Output: `GameScreen.tsx` completion `useEffect` calls `saveProgress` with all four arguments; dependency array unchanged.
</objective>

<execution_context>
@/Users/martha2022/.claude/get-shit-done/workflows/execute-plan.md
@/Users/martha2022/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/05-storage-and-score-utility/05-RESEARCH.md
@.planning/phases/05-storage-and-score-utility/05-01-SUMMARY.md
@src/components/GameScreen.tsx
@src/game/storage.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Pass state.score to saveProgress in GameScreen completion useEffect</name>
  <files>src/components/GameScreen.tsx</files>
  <action>
Find the completion `useEffect` in `src/components/GameScreen.tsx` (currently around lines 186–192). It looks like:

```typescript
useEffect(() => {
  if (state.status === 'completed') {
    saveProgress(state.level.id, state.stars, timeElapsed);
  }
  // eslint-disable-next-line react-hooks/exhaustive-deps
}, [state.status, state.stars]);
```

Change the `saveProgress` call to pass `state.score` as the fourth argument:

```typescript
useEffect(() => {
  if (state.status === 'completed') {
    // score read from closure, not deps — intentional: fires once per completion only
    saveProgress(state.level.id, state.stars, timeElapsed, state.score);
  }
  // eslint-disable-next-line react-hooks/exhaustive-deps
}, [state.status, state.stars]);
```

Critical constraints:
- Do NOT add `state.score` to the dependency array `[state.status, state.stars]`. If `score` enters the deps array, the effect fires on every vinyl placement (score increments mid-game), writing in-progress partial scores as personal bests. The lint suppression comment must stay.
- Do NOT remove the existing lint suppression — keep both the new comment about `score` and the existing `// eslint-disable-next-line react-hooks/exhaustive-deps`.
- This is a one-line change to the call site only; do not touch any other logic in GameScreen.
  </action>
  <verify>
    <automated>cd /Users/martha2022/Documents/Sleevo && npx tsc --noEmit 2>&1</automated>
    <manual>Search for `saveProgress` in `src/components/GameScreen.tsx` — the call must now have four arguments ending with `state.score`. Search for `state.score` in the dependency array — it must NOT be present.</manual>
    <sampling_rate>run after this task completes</sampling_rate>
  </verify>
  <done>TypeScript compiles with zero errors. The `saveProgress` call in the completion `useEffect` passes `state.score` as the fourth argument. The dependency array remains `[state.status, state.stars]`.</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Verify Phase 5 storage pipeline end-to-end in the browser</name>
  <action>Human verifies Phase 5 storage pipeline by playing the game and inspecting localStorage.</action>
  <verify>See how-to-verify below.</verify>
  <done>User confirms bestScore persists correctly and formatScore returns Italian-formatted output.</done>
  <what-built>
    Full Phase 5 storage pipeline:
    - `LevelProgress.bestScore?: number` field added
    - `saveProgress` extended with independent `scoreImproved` condition and spread-merge write
    - `formatScore` utility created (it-IT locale, hardcoded)
    - `GameScreen` completion effect now passes `state.score` to `saveProgress`
  </what-built>
  <how-to-verify>
    1. Open the game in the browser (`npm run dev` if not already running).
    2. Open DevTools → Application → Local Storage → `sleevo_progress` key. Clear it to start fresh.
    3. Complete any level. Inspect the localStorage entry for that level — it must contain a `bestScore` integer value alongside `stars` and optionally `bestTime`.
    4. Note your score. Replay the same level and score LOWER. Inspect localStorage — `bestScore` must be unchanged.
    5. Replay the same level and score HIGHER. Inspect localStorage — `bestScore` must now show the new higher value.
    6. Confirm `stars` and `bestTime` in the record were not erased by the score-only update.
    7. In the browser console run:
       ```javascript
       import('/src/utils/formatScore.ts').then(m => {
         console.log(m.formatScore(1420));      // must log: 1.420 pt
         console.log(m.formatScore(undefined)); // must log: —
       });
       ```
       Both assertions must pass.
  </how-to-verify>
  <resume-signal>Type "approved" to proceed, or describe any issues found</resume-signal>
</task>

</tasks>

<verification>
Run `npx tsc --noEmit` from project root — zero errors required.

Manual localStorage test (see checkpoint) confirms best-only semantics: lower score does not overwrite; higher score does overwrite; existing stars/bestTime are preserved.
</verification>

<success_criteria>
1. TypeScript builds with zero errors.
2. Completing a level for the first time writes `bestScore` to localStorage.
3. Replaying with a lower score leaves `bestScore` unchanged.
4. Replaying with a higher score updates `bestScore` to the new value.
5. The stored record retains `stars` and `bestTime` after a score-only update (merge-write confirmed).
6. `formatScore(1420)` returns `'1.420 pt'` in the browser (it-IT locale, dot separator).
</success_criteria>

<output>
After completion, create `.planning/phases/05-storage-and-score-utility/05-02-SUMMARY.md`
</output>
